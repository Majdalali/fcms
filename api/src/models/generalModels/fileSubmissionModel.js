const { firestore } = require("../../services/firebase");
class DataSubmission {
  constructor({
    submissionType,
    originalName,
    autogeneratedName,
    createdAt,
    studentId,
    projectType,
    remarksFromCoordinator,
    proposalStatus,
  }) {
    this.submissionType = submissionType;
    this.originalName = originalName;
    this.autogeneratedName = autogeneratedName;
    this.studentId = studentId;
    this.projectType = projectType;
    this.createdAt = createdAt;
    this.remarksFromCoordinator = remarksFromCoordinator;
    this.proposalStatus = proposalStatus;
  }

  static async saveDataSubmission(submissionType, fileSubmissionData) {
    try {
      const dataSubmissionCollection = firestore().collection(submissionType);

      // Loop through each fileSubmissionData item and save it individually
      for (const fileData of fileSubmissionData) {
        const {
          studentId,
          originalName,
          autogeneratedName,
          createdAt,
          projectType,
          proposalStatus,
          remarksFromCoordinator,
        } = fileData;

        // Add your validation logic here, checking if required properties exist and are valid

        const newDataSubmission = {
          submissionType,
          originalName,
          autogeneratedName,
          studentId,
          projectType,
          createdAt,
        };

        // Conditionally add proposalStatus and remarksFromCoordinator for "proposals" type
        if (submissionType === "proposals") {
          newDataSubmission.proposalStatus = proposalStatus || "pending";
          newDataSubmission.remarksFromCoordinator =
            remarksFromCoordinator || "";
        }

        await dataSubmissionCollection.add(newDataSubmission);
      }

      return { message: "Files info uploaded successfully" };
    } catch (error) {
      throw error;
    }
  }

  static async checkExistingSubmission(submissionType, studentId, projectType) {
    try {
      const submissionRef = firestore().collection(submissionType);
      const querySnapshot = await submissionRef
        .where("studentId", "==", studentId)
        .where("projectType", "==", projectType)
        .get();

      return !querySnapshot.empty;
    } catch (error) {
      throw error;
    }
  }
  static async getFileSubmissionsByStudentId(
    submissionType,
    studentId,
    projectType
  ) {
    try {
      const fileSubmissionsRef = firestore().collection(submissionType);
      const querySnapshot = await fileSubmissionsRef
        .where("studentId", "==", studentId)
        .where("projectType", "==", projectType)
        .get();

      const fileSubmissions = [];
      querySnapshot.forEach((doc) => {
        const fileSubmissionData = doc.data();
        const commonData = {
          originalName: fileSubmissionData.originalName,
          autogeneratedName: fileSubmissionData.autogeneratedName,
          studentId: fileSubmissionData.studentId,
          createdAt: fileSubmissionData.createdAt,
          projectType: fileSubmissionData.projectType,
        };

        let fileSubmission;
        if (submissionType === "proposals") {
          fileSubmission = new DataSubmission({
            ...commonData,
            proposalStatus: fileSubmissionData.proposalStatus,
            remarksFromCoordinator: fileSubmissionData.remarksFromCoordinator,
          });
        } else {
          fileSubmission = new DataSubmission(commonData);
        }
        fileSubmissions.push(fileSubmission);
      });

      if (fileSubmissions.length === 0) {
        return { error: "No recorded files" };
      }
      return fileSubmissions;
    } catch (error) {
      throw error;
    }
  }

  static async deleteFileByName(submissionType, studentId, fileName) {
    try {
      const fileSubmissionsRef = firestore().collection(submissionType);
      const querySnapshot = await fileSubmissionsRef
        .where("studentId", "==", studentId)
        .where("autogeneratedName", "==", fileName)
        .get();

      if (querySnapshot.empty) {
        return null;
      }

      const fileSubmissionDoc = querySnapshot.docs[0];
      await fileSubmissionDoc.ref.delete();
      return { message: "File deleted successfully" };
    } catch (error) {
      throw error;
    }
  }

  static async getAllFilesForCoordinator(collectionName) {
    try {
      const fileSubmissionsRef = firestore().collection(collectionName);
      const querySnapshot = await fileSubmissionsRef.get();

      const fileSubmissions = [];
      querySnapshot.forEach((doc) => {
        const fileSubmissionData = doc.data();
        const commonData = {
          originalName: fileSubmissionData.originalName,
          autogeneratedName: fileSubmissionData.autogeneratedName,
          studentId: fileSubmissionData.studentId,
          createdAt: fileSubmissionData.createdAt,
          projectType: fileSubmissionData.projectType,
          submissionType: fileSubmissionData.submissionType,
        };
        const fileSubmission = new DataSubmission(commonData);
        fileSubmissions.push(fileSubmission);
      });

      if (fileSubmissions.length === 0) {
        return { error: "No recorded files" };
      }
      return fileSubmissions;
    } catch (error) {
      throw error;
    }
  }

  static async getPendingProposalFilesForAdmin() {
    try {
      const proposalFiles = await Promise.all([
        firestore()
          .collection("proposals")
          .where("proposalStatus", "==", "pending")
          .get(),
        firestore().collection("proposalsExtras").get(),
      ]);

      const pendingProposalFiles = [];
      const pendingProposalExtraFiles = [];

      // Process data from "proposals" collection
      proposalFiles[0].forEach((doc) => {
        const fileData = doc.data();
        const proposalFile = {
          originalName: fileData.originalName,
          autogeneratedName: fileData.autogeneratedName,
          studentId: fileData.studentId,
          createdAt: fileData.createdAt,
          proposalStatus: fileData.proposalStatus,
          remarksFromCoordinator: fileData.remarksFromCoordinator,
        };
        pendingProposalFiles.push(proposalFile);
      });

      // Process data from "proposalsExtras" collection
      proposalFiles[1].forEach((doc) => {
        const fileData = doc.data();
        const proposalExtraFile = {
          originalName: fileData.originalName,
          autogeneratedName: fileData.autogeneratedName,
          studentId: fileData.studentId,
          createdAt: fileData.createdAt,
          // No proposalStatus or remarksFromCoordinator in proposalsExtras
        };
        pendingProposalExtraFiles.push(proposalExtraFile);
      });

      return {
        proposals: pendingProposalFiles,
        proposalsExtra: pendingProposalExtraFiles,
      };
    } catch (error) {
      throw error;
    }
  }

  static async updateProposalStatusAndRemarks(
    studentId,
    autogeneratedName,
    newStatus,
    newRemarks
  ) {
    try {
      const submissionType = "proposals"; // Assuming the submission type is 'proposals'

      // Find the specific proposal file based on studentId and autogeneratedName
      const proposalFileRef = firestore()
        .collection(submissionType)
        .where("studentId", "==", studentId)
        .where("autogeneratedName", "==", autogeneratedName);

      const querySnapshot = await proposalFileRef.get();

      if (querySnapshot.empty) {
        throw new Error("Proposal file not found");
      }

      // Assuming only one document matches the criteria
      const proposalFileDoc = querySnapshot.docs[0];

      // Update status and remarks
      await proposalFileDoc.ref.update({
        proposalStatus: newStatus,
        remarksFromCoordinator: newRemarks,
      });

      return { message: "Proposal status and remarks updated successfully" };
    } catch (error) {
      throw error;
    }
  }
}

module.exports = DataSubmission;
