const { firestore } = require("../../services/firebase");
class DataSubmission {
  constructor({
    submissionType,
    originalName,
    autogeneratedName,
    createdAt,
    studentId,
    remarksFromCoordinator,
    proposalStatus,
  }) {
    this.submissionType = submissionType;
    this.originalName = originalName;
    this.autogeneratedName = autogeneratedName;
    this.studentId = studentId;
    this.createdAt = createdAt;
    this.remarksFromCoordinator = remarksFromCoordinator;
    this.proposalStatus = proposalStatus;
  }

  static async saveDataSubmission(submissionType, fileSubmissionData) {
    try {
      const dataSubmissionCollection = firestore().collection(submissionType);

      // Loop through each fileSubmissionData item and save it individually
      for (const fileData of fileSubmissionData) {
        const {
          studentId,
          originalName,
          autogeneratedName,
          createdAt,
          proposalStatus,
          remarksFromCoordinator,
        } = fileData;

        // Add your validation logic here, checking if required properties exist and are valid

        const newDataSubmission = {
          submissionType,
          originalName,
          autogeneratedName,
          studentId,
          createdAt,
        };

        // Conditionally add proposalStatus and remarksFromCoordinator for "proposals" type
        if (submissionType === "proposals") {
          newDataSubmission.proposalStatus = proposalStatus || "pending";
          newDataSubmission.remarksFromCoordinator =
            remarksFromCoordinator || "";
        }

        await dataSubmissionCollection.add(newDataSubmission);
      }

      return { message: "Files info uploaded successfully" };
    } catch (error) {
      throw error;
    }
  }

  static async checkExistingSubmission(submissionType, studentId) {
    try {
      const submissionRef = firestore().collection(submissionType);
      const querySnapshot = await submissionRef
        .where("studentId", "==", studentId)
        .get();

      return !querySnapshot.empty;
    } catch (error) {
      throw error;
    }
  }
  static async getFileSubmissionsByStudentId(submissionType, studentId) {
    try {
      const fileSubmissionsRef = firestore().collection(submissionType);
      const querySnapshot = await fileSubmissionsRef
        .where("studentId", "==", studentId)
        .get();

      const fileSubmissions = [];
      querySnapshot.forEach((doc) => {
        const fileSubmissionData = doc.data();
        const commonData = {
          originalName: fileSubmissionData.originalName,
          autogeneratedName: fileSubmissionData.autogeneratedName,
          studentId: fileSubmissionData.studentId,
          createdAt: fileSubmissionData.createdAt,
        };

        let fileSubmission;
        if (submissionType === "proposals") {
          fileSubmission = new DataSubmission({
            ...commonData,
            proposalStatus: fileSubmissionData.proposalStatus,
            remarksFromCoordinator: fileSubmissionData.remarksFromCoordinator,
          });
        } else {
          fileSubmission = new DataSubmission(commonData);
        }
        fileSubmissions.push(fileSubmission);
      });

      if (fileSubmissions.length === 0) {
        return { error: "No recorded files" };
      }
      return fileSubmissions;
    } catch (error) {
      throw error;
    }
  }

  static async deleteFileByName(submissionType, studentId, fileName) {
    try {
      const fileSubmissionsRef = firestore().collection(submissionType);
      const querySnapshot = await fileSubmissionsRef
        .where("studentId", "==", studentId)
        .where("autogeneratedName", "==", fileName)
        .get();

      if (querySnapshot.empty) {
        return null;
      }

      const fileSubmissionDoc = querySnapshot.docs[0];
      await fileSubmissionDoc.ref.delete();
      return { message: "File deleted successfully" };
    } catch (error) {
      throw error;
    }
  }

  // static async getFileSubmissionById(submissionType, studentId) {
  //   try {
  //     const fileSubmissionsRef = firestore().collection(submissionType);
  //     const querySnapshot = await fileSubmissionsRef
  //       .where("studentId", "==", studentId)
  //       .get();

  //     if (querySnapshot.empty) {
  //       return null;
  //     }

  //     const fileSubmissionData = querySnapshot.docs[0].data();
  //     return new FileSubmission({
  //       originalName: fileSubmissionData.originalName,
  //       autogeneratedName: fileSubmissionData.autogeneratedName,
  //       studentId: fileSubmissionData.studentId,
  //       createdAt: fileSubmissionData.createdAt.toDate(),
  //     });
  //   } catch (error) {
  //     throw error;
  //   }
  // }

  static async getPendingProposalFilesForAdmin() {
    try {
      const submissionType = "proposals"; // Assuming the submission type is 'proposals'

      const proposalFiles = await firestore()
        .collection(submissionType)
        .where("proposalStatus", "==", "pending")
        .get();

      const pendingProposalFiles = [];
      proposalFiles.forEach((doc) => {
        const fileData = doc.data();
        const proposalFile = {
          originalName: fileData.originalName,
          autogeneratedName: fileData.autogeneratedName,
          studentId: fileData.studentId,
          createdAt: fileData.createdAt,
          proposalStatus: fileData.proposalStatus,
          remarksFromCoordinator: fileData.remarksFromCoordinator,
        };
        pendingProposalFiles.push(proposalFile);
      });

      return pendingProposalFiles;
    } catch (error) {
      throw error;
    }
  }
  static async updateProposalStatusAndRemarks(
    studentId,
    autogeneratedName,
    newStatus,
    newRemarks
  ) {
    try {
      const submissionType = "proposals"; // Assuming the submission type is 'proposals'

      // Find the specific proposal file based on studentId and autogeneratedName
      const proposalFileRef = firestore()
        .collection(submissionType)
        .where("studentId", "==", studentId)
        .where("autogeneratedName", "==", autogeneratedName);

      const querySnapshot = await proposalFileRef.get();

      if (querySnapshot.empty) {
        throw new Error("Proposal file not found");
      }

      // Assuming only one document matches the criteria
      const proposalFileDoc = querySnapshot.docs[0];

      // Update status and remarks
      await proposalFileDoc.ref.update({
        proposalStatus: newStatus,
        remarksFromCoordinator: newRemarks,
      });

      return { message: "Proposal status and remarks updated successfully" };
    } catch (error) {
      throw error;
    }
  }
}

module.exports = DataSubmission;
