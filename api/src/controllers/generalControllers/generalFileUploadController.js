const multer = require("multer");
const crypto = require("crypto");
const path = require("path");
const jwt = require("jsonwebtoken");
const GFile = require("../../models/generalModels/generalFileUploadModel");
const fs = require("fs/promises");

let randomFileName;

const gStorage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, "./uploads"); // Set a specific destination for CV files
  },
  filename: function (req, file, cb) {
    const randomString = crypto.randomBytes(10).toString("hex");
    const fileExtension = path.extname(file.originalname);
    randomFileName = randomString + fileExtension; // Assign the generated name to the variable
    cb(null, randomFileName);
  },
});

const gUpload = multer({ storage: gStorage });

async function generalizedUploadFile(req, res) {
  const token = req.headers.authorization;
  const { submissionType } = req.body;

  try {
    // Validate the submission type before proceeding
    // if (!isValidSubmissionType(submissionType)) {
    //   return res.status(400).json({ error: "Invalid submission type" });
    // }

    const decoded = jwt.verify(token, process.env.SECRET_TOKEN);
    const userId = decoded.user_id;

    const files = req.files;

    const fileSubmissionData = files.map((file) => ({
      originalName: file.originalname,
      autogeneratedName: file.filename,
      userId: userId,
      createdAt: new Date(),
    }));

    // Handle data saving and related notifications
    await GFile.saveGFile(fileSubmissionData, submissionType);

    return res.status(200).json({
      message: "File info uploaded successfully",
      fileSubmissionData,
    });
  } catch (error) {
    console.error("Error uploading a file:", error);
    return res.status(500).json({ error: "Internal server error" });
  }
}

async function getFilesByCollection(req, res) {
  const { collectionName } = req.params;

  try {
    const gFiles = await GFile.fetchGFiles(collectionName);

    if (!gFiles.length) {
      return res.status(404).json({ error: "No files found" });
    }

    return res.status(200).json(gFiles);
  } catch (error) {
    console.error("Error fetching files:", error);
    return res.status(500).json({ error: "Internal server error" });
  }
}

async function deleteGFile(req, res) {
  const { fileId } = req.params;
  const { collectionName, fileName } = req.body;

  try {
    const result = await GFile.deleteGFile(collectionName, fileId);

    if (!result) {
      return res.status(404).json({ error: "File not found" });
    }

    // Delete the file from the uploads folder
    const filePath = path.join("./uploads", fileName);
    await fs.unlink(filePath);

    return res.status(200).json(result);
  } catch (error) {
    console.error("Error deleting file:", error);
    return res.status(500).json({ error: "Internal server error" });
  }
}

async function deleteGFileByAutogeneratedName(req, res) {
  const { autogeneratedName } = req.params;
  const { collectionName } = req.body;

  try {
    const result = await GFile.deleteGFileByAutogeneratedName(
      collectionName,
      autogeneratedName
    );

    if (!result) {
      return res.status(404).json({ error: "File not found" });
    }

    // Delete the file from the uploads folder
    const filePath = path.join("./uploads", autogeneratedName);
    await fs.unlink(filePath);

    return res.status(200).json(result);
  } catch (error) {
    console.error("Error deleting file:", error);
    return res.status(500).json({ error: "Internal server error" });
  }
}

module.exports = {
  gUpload,
  generalizedUploadFile,
  getFilesByCollection,
  deleteGFile,
  deleteGFileByAutogeneratedName,
};
